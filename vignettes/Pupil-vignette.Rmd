---
title: "Pupil Preprocessing"
author: "Jason Geller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


This is an R markdown file explaining pupil preprocessing functions contained in the gazeR package. The example dataset is from a lexical decison task that had individuals judge the lexicality of printed stimuli and cursive stimuli. Cursive stimuli are ambigious and non-segemneted making them really hard to recognize. It was predicted that it should be harder to recognize cursive words than printed words. Good thing we have this new package to help us test this hypothesis! 

# Preparing your data

Before using this package, a number of steps are required: First, your data must have been collected using an SR Research Eyelink eye tracker. Second, your data must have been exported using SR Research Data Viewer software. Third, I recommend extending blinks 100 ms before and after a blink in Data Viewer. However, that is not neccessary as we have a function that will do that for you! A Sample Report must be generated with the following columns: 


```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=FALSE}
names_needed <- c("RECORDING_SESSION_LABEL","TRIAL_INDEX","AVERAGE_IN_BLINK","TIMESTAMP","AVERAGE_PUPIL_SIZE", "IP_START_TIME", "SAMPLE_MESSAGE")
knitr::kable(names_needed, col.names = "Names")
```

You should also include columns important for your experiment. 

# Load Package

```{r, message=FALSE, warning=FALSE}
install_github("dmirman/gazer")
```

# Load Data
We need to read in the file that contains data from 4 participants to reduce computational processing. 

```{r}
pupil_path <- system.file("extdata", "Pupil_file1.xls", package = "gazer")
pupil_sub1<-read.table(pupil_path)
```

In reality, you will have many Ss files. The function `merge_pupil_files` will take all your pupil files from a folder path and merge them together. It will also: rename columns, make all columns lowercase, and adds a new column `time` that places tracker time in ms. 

```{r}
pupil_files<-merge_pupil_files(file_list)
```

# Behavioral Data

If you are also interested in analyzing behavioral data (RTs and accuracy), the `behave_data` function will cull the important behavioral data from the Sample Report. `behave_data` will return a data frame without errors when omiterrors=TRUE or a data frame with errors for accuracy/error analysis when omiterrors=FALSE. The columns relevant for your experiment need to be specified within the behave_col names argument. This does not eliminate outliers. You must use your preferred method. I recommend the very good `trimr` package by Jim Grange. 


```{r}
behave_data<-behave_pupil(pupil_files, omiterrors = FALSE, behave_colnames = c("subject","script","alteration", "trial", "target","accuracy","rt", "block", "cb"))

```

# Blinks

Subjects and trials with a lot of missing data--due to blinks--should be removed. `missing_pupil_count`will remove subjects and items that pass a specififed missing threshold (we have it set at .3, but users can change this to whatever value they would like). The percentage of subjects and trials thrown out are returned for reporting.    

```{r}
pup_missing<-missing_pupil_count(pupil_files1, missingthresh = .3)
```

## Extending Blinks

If you are exporting files from SR, there is an option to extend blinks within Data Viewer. It is generally recommedned that you extend blinks 100 ms before the blink and 100 ms after the blink. If you have not done this before exporting into R, you can use the `extend_blinks` funtion. The fillback argument extends blinks back in time and the fillforward argument extends blinks forward in time. For this experiment the tracker sampled at 250hz (once every 4 ms). If we want to extend 100 ms forward and backward in time, we set those arguments to 25. 

```{r}
pup_extend<- pup_missing %>% group_by(subject, trial, time) %>% mutate(extendblink=extendblinks(pupil, fillback=25, fillforward=25))
```

# Interpolation of Pupil Values

Pupil values need to be linearlly interpolated. The `interpolate_pupil` function sets all pupil values with blinks to NA if extendblink=FALSE (SR does not this with sample files automatically) and linearlly interpolates those values. If extendblinks=TRUE, it performs linerally interpolation. This requires the use of the `extend_blinks` function referenced above. 

```{r}
pup_interp<-interpolate_pupil(pup_outliers, extendblinks=TRUE)
```

# Median Absoulate Deviation (MAD)

Artifacts that arise from quick changes in pupil size shoul be removed (Kret & Sjak-Shie, in press). The max_dilation function calculates the nomralized dilation speed, which is the max absoulte change between samples divided by the temporal speration for each sample, preceding or succeeding the sample. To detect outliters, the median abosulate deviation is calcualted from the speed dilation variable, multipled by a constant, and added to the median dilation speed variable--values above this threshold are then removed. 

```{r}
max_pup<-pup_interp%>% group_by(subject, trial) %>% mutate(speed=speed_pupil(interp,time))
mad_pup<-max_pup %>% group_by(subject, trial) %>% mutate(MAD=calc_mad(speed))
mad_removal<-mad_pup %>% filter(speed < MAD)
mad_removal<-as.data.frame(mad_removal)
```

# Smoothing

Pupil data can be extremely nosiy! One way to reduce some of this noise is to use a n-point moving average to smooth the data. You can use the `movingAverage` function. To use this function, you need to specify the column that contains the interpolated pupil values and how many samples you want to avearge over. In this example, we use a 5-point moving average (n= 5). However, you can set the moving average to whatever you would like. 

```{r, echo=FALSE}
rolling_mean_pupil_average<-mad_removal %>% 
        dplyr::select(subject, trial,target, script,alteration, time, interp, sample_message) %>%
        dplyr::mutate(movingavgpup= movingAverage(mad_removal$interp,n=5))
```

# Baseline correction

To control for variability arising from non-task related processing, baseline correction is commonly done. There are several different types of baseline correction. In a recent paper by Mathot et al. (2018), it was reccomended that a subtractive baseline correction be done based on the median. The `baseline_correction_pupil` function finds the median pupil size during a specified baseline period for each trial. In this exmaple, we used a baseline window between 500 ms and 1000 ms (when the fixation cross was on screen) and subtracted this value from each pupil trace. 

```{r, echo=FALSE}
baseline_pupil<-baseline_correction_pupil(timebins1, baseline_window=c(500,1000))
```





